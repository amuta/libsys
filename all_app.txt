
### app/channels/application_cable/connection.rb ###
module ApplicationCable
  class Connection < ActionCable::Connection::Base
    identified_by :current_user

    def connect
      set_current_user || reject_unauthorized_connection
    end

    private
      def set_current_user
        if session = Session.find_by(id: cookies.signed[:session_id])
          self.current_user = session.user
        end
      end
  end
end

### app/controllers/api/v1/base_controller.rb ###
class Api::V1::BaseController < ApplicationController
  before_action :set_default_format

  private

  def set_default_format
    request.format = :json
  end
end
### app/controllers/api/v1/books_controller.rb ###
class Api::V1::BooksController < Api::V1::BaseController
  before_action :authenticate!

  def index
    @books = policy_scope(Book)
              .search(params[:q])
              .includes(:genres, contributions: :agent)
              .order(created_at: :desc)
    render :index
  end

  def show
    @book = Book.find(params[:id]); authorize @book
    render :show
  end

  def create
    authorize Book
    Book.transaction do
      @book = Book.create!(book_params)
      @book.genre_ids = Array(params.dig(:book, :genre_ids)).map!(&:to_i).uniq
      @book.author_ids = Array(params.dig(:book, :author_ids))
    end
    render :show, status: :created
  end

  def update
    @book = Book.find(params[:id]); authorize @book
    Book.transaction do
      @book.update!(book_params)
      @book.genre_ids = Array(params.dig(:book, :genre_ids)).map!(&:to_i).uniq
      @book.author_ids = Array(params.dig(:book, :author_ids))
    end
    head :no_content
  end

  def destroy
    @book = Book.find(params[:id]); authorize @book
    @book.destroy!
    head :no_content
  end

  def borrow
    @book = Book.find(params[:id]); authorize @book, :show?
    @loan = Loan::Create.call!(user: Current.user, loanable: @book)
    render "api/v1/loans/show", status: :created
  end

  def copies
    @book = Book.find(params[:id]); authorize @book, :update?
    @copy = @book.copies.create!(barcode: params.require(:barcode))
    render "api/v1/copies/show", status: :created
  end

  private

  def book_params
    params.require(:book).permit(:title, :isbn, :language)
  end
end

### app/controllers/api/v1/copies_controller.rb ###
class Api::V1::CopiesController < Api::V1::BaseController
  before_action :authenticate!

  def destroy
    @copy = Copy.find(params[:id])
    authorize @copy, :destroy?
    return render(json: { error: "active_loan" }, status: :conflict) if @copy.active_loan.present?
    @copy.destroy!
    head :no_content
  end
end

### app/controllers/api/v1/genres_controller.rb ###
class Api::V1::GenresController < Api::V1::BaseController
  before_action :authenticate!

  def search
    @genres = Genre.search(params[:q])
    render :search
  end
end

### app/controllers/api/v1/loans_controller.rb ###
class Api::V1::LoansController < Api::V1::BaseController
  before_action :authenticate!

  def index
    scope = policy_scope(Loan).includes(:user, copy: :loanable).order(created_at: :desc)
    scope = scope.where(user: Current.user) if params[:mine].present?
    @loans = scope
    render :index
  end

  def return
    @loan = Loan.find(params[:id])
    authorize @loan, :return?
    Loan::Return.call!(librarian: Current.user, loan: @loan)
    head :no_content
  end
end

### app/controllers/api/v1/people_controller.rb ###
class Api::V1::PeopleController < Api::V1::BaseController
  before_action :authenticate!

  def search
    @people = Person.search(params[:q])
    render :search
  end
end

### app/controllers/api/v1/registrations_controller.rb ###
class Api::V1::RegistrationsController < Api::V1::BaseController
  def create
    user = User.create!(user_params)
    session = user.sessions.create!(user_agent: request.user_agent, ip_address: request.remote_ip)

    cookies.encrypted[:session_token] = {
      value: session.id, httponly: true, secure: Rails.env.production?, same_site: :strict
    }
    Current.session = session
    @session = session
    render "api/v1/sessions/create", status: :created
  end

  private

  def user_params
    params.require(:user).permit(:name, :email_address, :password, :password_confirmation)
  end
end

### app/controllers/api/v1/sessions_controller.rb ###
class Api::V1::SessionsController < Api::V1::BaseController
  def create
    user = User.find_by(email_address: params[:email_address])
    if user&.authenticate(params[:password])
      @session = user.sessions.create!(user_agent: request.user_agent, ip_address: request.remote_ip)
      cookies.encrypted[:session_token] = { value: @session.id, httponly: true, secure: Rails.env.production?, same_site: :strict }
      Current.session = @session
      render :create, status: :created
    else
      head :unauthorized
    end
  end

  def show
    authenticate!
    @user = Current.user
    render :show
  end

  def destroy
    if Current.session
      Current.session.destroy
      cookies.delete(:session_token)
      Current.session = nil
    end
    head :no_content
  end
end

### app/controllers/application_controller.rb ###
class ApplicationController < ActionController::API
  include ActionController::Cookies
  include Pundit::Authorization

  before_action :set_current_session

  rescue_from Pundit::NotAuthorizedError do
    render json: { error: "forbidden" }, status: :forbidden
  end

  rescue_from ActiveRecord::RecordNotFound do
    render json: { error: "not_found" }, status: :not_found
  end

  rescue_from Loan::Exceptions::NotAvailable do
    render json: { error: "not_available" }, status: :unprocessable_content
  end

  rescue_from Loan::Exceptions::AlreadyBorrowed do
    render json: { error: "already_borrowed" }, status: :conflict
  end

  rescue_from ActiveRecord::RecordInvalid do |exception|
    error_messages = exception.record.errors.full_messages
    render json: { error: "validation_failed", messages: error_messages }, status: :unprocessable_content
  end

  def authenticate!
    head :unauthorized unless Current.user
  end

  def current_user
    Current.user
  end

  private

  def set_current_session
    sid = cookies.encrypted[:session_token]
    return unless sid
    Current.session = Session.find_by(id: sid)
  end
end

### app/controllers/concerns/.keep ###

### app/jobs/application_job.rb ###
class ApplicationJob < ActiveJob::Base
  # Automatically retry jobs that encountered a deadlock
  # retry_on ActiveRecord::Deadlocked

  # Most jobs are safe to ignore if the underlying records are no longer available
  # discard_on ActiveJob::DeserializationError
end

### app/mailers/application_mailer.rb ###
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout "mailer"
end

### app/mailers/passwords_mailer.rb ###
class PasswordsMailer < ApplicationMailer
  def reset(user)
    @user = user
    mail subject: "Reset your password", to: user.email_address
  end
end

### app/models/application_record.rb ###
class ApplicationRecord < ActiveRecord::Base
  primary_abstract_class
end

### app/models/book_genre.rb ###
class BookGenre < ApplicationRecord
  belongs_to :book
  belongs_to :genre
  validates :book_id, uniqueness: { scope: :genre_id }
end

### app/models/book.rb ###
class Book < ApplicationRecord
  include Loanable
  include Catalogable
  include Book::Searchable

  has_many :book_genres, dependent: :destroy
  has_many :genres, through: :book_genres

  validates :title, presence: true
  validates :isbn, format: { with: /\A[0-9X-]+\z/i }, allow_blank: true

  # typed helpers remain
  def authors = contributor_agents(role: :author, agent_type: "Person")
  def author_ids = contributions.where(role: :author, agent_type: "Person").pluck(:agent_id)
  def author_ids=(ids)
    replace_contributors!(role: :author, agent_type: "Person", agent_ids: ids)
  end
end

### app/models/book/searchable.rb ###
# frozen_string_literal: true

module Book::Searchable
  extend ActiveSupport::Concern

  included do
    scope :search, ->(q) {
      next all if q.blank?

      qn      = ActiveRecord::Base.sanitize_sql_like(q.to_s.downcase)
      pattern = "%#{qn}%"
      author_role = Contribution.roles[:author]

      joins(<<~SQL)
        LEFT JOIN contributions
          ON contributions.catalogable_type = 'Book'
         AND contributions.catalogable_id   = books.id
         AND contributions.role             = #{author_role}
         AND contributions.agent_type       = 'Person'
        LEFT JOIN people       ON people.id       = contributions.agent_id
        LEFT JOIN book_genres  ON book_genres.book_id = books.id
        LEFT JOIN genres       ON genres.id       = book_genres.genre_id
      SQL
        .where(
          "LOWER(books.title) LIKE :q OR LOWER(people.name) LIKE :q OR LOWER(genres.name) LIKE :q",
          q: pattern
        )
        .distinct
    }
  end
end

### app/models/concerns/catalogable.rb ###
module Catalogable
  extend ActiveSupport::Concern

  included do
    has_many :contributions, as: :catalogable, dependent: :destroy
  end

  def contributors(role:, agent_type: "Person")
    contributions.includes(:agent).where(role:, agent_type:)
  end

  def contributor_agents(role:, agent_type: "Person")
    contributors(role:, agent_type:).map(&:agent)
  end

  # replace-all
  def replace_contributors!(role:, agent_type: "Person", agent_ids:)
    contributions.where(role:, agent_type:).delete_all
    ids = Array(agent_ids).map!(&:to_i).uniq
    return if ids.empty?

    now = Time.current
    rows = ids.map do |agent_id|
      {
        catalogable_type: self.class.name,
        catalogable_id:   self.id,
        agent_type:       agent_type,
        agent_id:         agent_id,
        role:             Contribution.roles.fetch(role),
        position:         1,
        created_at:       now,
        updated_at:       now
      }
    end
    Contribution.insert_all!(rows)
  end
end

### app/models/concerns/.keep ###

### app/models/concerns/loanable.rb ###
module Loanable
  extend ActiveSupport::Concern
  included do
    has_many :copies, as: :loanable, dependent: :restrict_with_error
  end
  def available_copies_count = copies.available.count
  def loan_to!(user)            = Loan::Create.call!(user:, loanable: self)
  def return!(loan, librarian:) = Loan::Return.call!(librarian:, loan:)
end

### app/models/contribution.rb ###
class Contribution < ApplicationRecord
  belongs_to :catalogable, polymorphic: true
  belongs_to :agent,       polymorphic: true

  enum :role, {
    author: 0, co_author: 1, editor: 2, translator: 3,
    donor: 30, owner: 40, cataloger: 43, sponsor: 52, other: 99
  }

  validates :agent_id, uniqueness: { scope: %i[catalogable_type catalogable_id agent_type role] }
end

### app/models/copy.rb ###
class Copy < ApplicationRecord
  belongs_to :loanable, polymorphic: true
  enum :status, { available: 0, loaned: 1 }, default: :available
  has_many :loans
  has_one :active_loan, -> { where(status: Loan.statuses[:active]) }, class_name: "Loan"
  validates :barcode, presence: true, uniqueness: true
end

### app/models/current.rb ###
class Current < ActiveSupport::CurrentAttributes
  attribute :session
  delegate :user, to: :session, allow_nil: true
end

### app/models/genre.rb ###
class Genre < ApplicationRecord
  has_many :book_genres, dependent: :destroy
  has_many :books, through: :book_genres
  validates :name, presence: true, uniqueness: { case_sensitive: false }
  scope :search, ->(q) { q.present? ? where("LOWER(name) LIKE ?", "%#{q.downcase}%") : all }
end

### app/models/loan/create.rb ###
class Loan::Create
  def self.call(user:, loanable:)
    Pundit.authorize(user, Loan, :create?)
    Copy.transaction do
      copy = loanable.copies.lock.available.first
      raise Loan::Exceptions::NotAvailable unless copy

      # Check if user already has an active loan for this loanable
      existing_loan = Loan.joins(:copy).where(user: user, loanable: loanable, status: :active).exists?
      raise Loan::Exceptions::AlreadyBorrowed if existing_loan

      loan = Loan.new(copy:, user:, loanable:)
      loan.save!
      copy.update!(status: :loaned)
      loan
    end
  end
end

### app/models/loan/defaults.rb ###
# app/models/loan/defaults.rb
module Loan::Defaults
  extend ActiveSupport::Concern
  DEFAULT_LOAN_DAYS = 14
  included { before_validation :set_defaults, on: :create }
  private
  def set_defaults
    self.borrowed_at ||= Time.current
    self.due_at      ||= borrowed_at + DEFAULT_LOAN_DAYS.days
    self.status      ||= :active
  end
end

### app/models/loan/exceptions.rb ###
module Loan::Exceptions
  class NotAvailable < StandardError; end
  class AlreadyBorrowed < StandardError; end
end
### app/models/loan.rb ###
class Loan < ApplicationRecord
  include Loan::Defaults
  include Loan::Rules

  belongs_to :copy
  belongs_to :user
  belongs_to :loanable, polymorphic: true

  enum :status, { active: 0, returned: 1 }

  scope :overdue_now, -> { active.where("due_at < ?", Time.current) }

  def overdue?
    active? && due_at.present? && due_at < Time.current
  end

  def status_now
    return "returned" if returned?
    return "overdue"  if overdue?
    "active"
  end
end

### app/models/loan/return.rb ###
class Loan::Return
  def self.call(librarian:, loan:)
    Pundit.authorize(librarian, loan, :return?)
    Copy.transaction do
      raise "already_returned" if loan.returned?
      loan.update!(returned_at: Time.current, status: :returned)
      loan.copy.update!(status: :available)
      true
    end
  end
end

### app/models/loan/rules.rb ###
module Loan::Rules
  extend ActiveSupport::Concern
  included do
    validate :copy_is_available, on: :create
    validate :due_after_borrowed
  end
  private
  def copy_is_available
    errors.add(:copy, "not available") unless copy&.available?
  end

  def due_after_borrowed
    return if borrowed_at.blank? || due_at.blank?
    errors.add(:due_at, "must be after borrowed_at") if due_at <= borrowed_at
  end
end

### app/models/person.rb ###
class Person < ApplicationRecord
  has_many :contributions, as: :agent, dependent: :destroy
  has_many :books, through: :contributions, source: :catalogable, source_type: "Book"
  validates :name, presence: true, uniqueness: { case_sensitive: false }
  scope :search, ->(q) { q.present? ? where("LOWER(name) LIKE ?", "%#{q.downcase}%") : all }
end

### app/models/session.rb ###
class Session < ApplicationRecord
  belongs_to :user
end

### app/models/user.rb ###
class User < ApplicationRecord
  has_secure_password
  has_many :sessions, dependent: :destroy
  has_many :loans, dependent: :restrict_with_error
  enum :role, { librarian: 0, member: 1 }, default: :member

  normalizes :email_address, with: ->(e) { e.strip.downcase }

  validates :name, presence: true
  validates :email_address, presence: true, uniqueness: { case_sensitive: false }
  validates :password, length: { minimum: 8 }, if: -> { password_digest_changed? }
end

### app/policies/application_policy.rb ###
# frozen_string_literal: true

class ApplicationPolicy
  attr_reader :user, :record

  def initialize(user, record)
    @user = user
    @record = record
  end

  def index?
    false
  end

  def show?
    false
  end

  def create?
    false
  end

  def new?
    create?
  end

  def update?
    false
  end

  def edit?
    update?
  end

  def destroy?
    false
  end

  class Scope
    def initialize(user, scope)
      @user = user
      @scope = scope
    end

    def resolve
      raise NoMethodError, "You must define #resolve in #{self.class}"
    end

    private

    attr_reader :user, :scope
  end
end

### app/policies/book_policy.rb ###
class BookPolicy < ApplicationPolicy
  def index?
    user.present?
  end

  def show?
    user.present?
  end

  def create?
    user&.librarian?
  end

  def update?
    user&.librarian?
  end

  def destroy?
    user&.librarian?
  end

  class Scope < ApplicationPolicy::Scope
    def resolve
      scope.all
    end
  end
end

### app/policies/copy_policy.rb ###
class CopyPolicy < ApplicationPolicy
  def create?
    user&.librarian?
  end

  def destroy?
    user&.librarian?
  end

  class Scope < ApplicationPolicy::Scope
    def resolve
      scope.all
    end
  end
end
### app/policies/loan_policy.rb ###
class LoanPolicy < ApplicationPolicy
  def index?
    user.present?
  end

  def show?
    user.present?
  end

  def create?
    user.present?
  end

  def update?
    user&.librarian?
  end

  def return?
    user&.librarian?
  end

  class Scope < ApplicationPolicy::Scope
    def resolve
      scope.all
    end
  end
end

### app/views/api/v1/books/_book.json.jbuilder ###
json.extract! book, :id, :title, :isbn, :language
json.available_copies book.available_copies_count
json.genres book.genres, :id, :name
json.authors book.contributions.where(role: :author, agent_type: "Person").includes(:agent).order(:position) do |c|
  json.id   c.agent_id
  json.name c.agent.name
end

### app/views/api/v1/books/index.json.jbuilder ###
json.array! @books do |b|
  json.partial! "api/v1/books/book", book: b
end

### app/views/api/v1/books/show.json.jbuilder ###
json.partial! "api/v1/books/book", book: @book

### app/views/api/v1/copies/show.json.jbuilder ###
json.extract! @copy, :id, :barcode, :status
json.loanable_type @copy.loanable_type
json.loanable_id   @copy.loanable_id
### app/views/api/v1/genres/search.json.jbuilder ###
json.array! @genres, :id, :name
### app/views/api/v1/loans/index.json.jbuilder ###
json.array! @loans do |l|
  json.partial! "api/v1/loans/loan", loan: l
end

### app/views/api/v1/loans/_loan.json.jbuilder ###
json.extract! loan, :id, :status, :borrowed_at, :due_at, :returned_at, :copy_id
json.loanable_type loan.loanable_type
json.loanable_id   loan.loanable_id
json.title         loan.copy.loanable.try(:title)
json.overdue       loan.overdue?
json.status_now    loan.status_now

if Current.user&.librarian?
  json.user_id loan.user_id
  json.user_email loan.user.email_address
  json.user_name(loan.user.name)
end

### app/views/api/v1/loans/show.json.jbuilder ###
json.partial! "api/v1/loans/loan", loan: @loan

### app/views/api/v1/people/search.json.jbuilder ###
json.array! @people, :id, :name
### app/views/api/v1/sessions/create.json.jbuilder ###
json.user do
  json.id            @session.user.id
  json.email_address @session.user.email_address
  json.name          @session.user.name
  json.role          @session.user.role
end
### app/views/api/v1/sessions/show.json.jbuilder ###
json.user do
  json.id            @user.id
  json.email_address @user.email_address
  json.name          @user.name
  json.role          @user.role
end
### app/views/layouts/mailer.html.erb ###
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <style>
      /* Email styles need to be inline */
    </style>
  </head>

  <body>
    <%= yield %>
  </body>
</html>

### app/views/layouts/mailer.text.erb ###
<%= yield %>

### app/views/passwords_mailer/reset.html.erb ###
<p>
  You can reset your password within the next 15 minutes on
  <%= link_to "this password reset page", edit_password_url(@user.password_reset_token) %>.
</p>

### app/views/passwords_mailer/reset.text.erb ###
You can reset your password within the next 15 minutes on this password reset page:
<%= edit_password_url(@user.password_reset_token) %>

### lib-frontend/src/api/books.ts ###
import { api } from "./client";
export const listBooks=(q="")=> api.get("/api/v1/books",{params:{q}}).then(r=>r.data);
export const getBook  =(id:number)=> api.get(`/api/v1/books/${id}`).then(r=>r.data);
export const createBook=(b:any)=> api.post("/api/v1/books",{book:b}).then(r=>r.data);
export const updateBook=(id:number,b:any)=> api.patch(`/api/v1/books/${id}`,{book:b});
export const deleteBook=(id:number)=> api.delete(`/api/v1/books/${id}`);
export const addCopy=(id:number,barcode:string)=> api.post(`/api/v1/books/${id}/copies`,{barcode}).then(r=>r.data);
export const borrow=(id:number)=> api.post(`/api/v1/books/${id}/borrow`).then(r=>r.data);

### lib-frontend/src/api/client.ts ###
import axios from "axios";
export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  withCredentials: true,
});

### lib-frontend/src/api/loans.ts ###
import { api } from "./client";
export const fetchLoans = (mine=false) => api.get("/api/v1/loans", { params: mine ? { mine: 1 } : {} }).then(r=>r.data);
export const returnLoan = (id:number) => api.patch(`/api/v1/loans/${id}/return`);

### lib-frontend/src/api/lookups.ts ###
import { api } from "./client";
export const searchPeople=(q:string)=> api.get("/api/v1/people/search",{params:{q}}).then(r=>r.data);
export const searchGenres=(q:string)=> api.get("/api/v1/genres/search",{params:{q}}).then(r=>r.data);

### lib-frontend/src/api/session.ts ###
import { api } from "./client";
export const whoami = async()=> {
  try { const r = await api.get("/api/v1/session"); return r.data?.user ?? null; }
  catch(e:any){ if(e?.response?.status===401) return null; throw e; }
};
export const login  = async(e:string,p:string)=> (await api.post("/api/v1/session",{ email_address:e, password:p })).data.user;
export const logout = async()=> { await api.delete("/api/v1/session"); };

### lib-frontend/src/App.css ###
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

### lib-frontend/src/App.tsx ###
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'

function App() {
  const [count, setCount] = useState(0)

  return (
    <>
      <div>
        <a href="https://vite.dev" target="_blank">
          <img src={viteLogo} className="logo" alt="Vite logo" />
        </a>
        <a href="https://react.dev" target="_blank">
          <img src={reactLogo} className="logo react" alt="React logo" />
        </a>
      </div>
      <h1>Vite + React</h1>
      <div className="card">
        <button onClick={() => setCount((count) => count + 1)}>
          count is {count}
        </button>
        <p>
          Edit <code>src/App.tsx</code> and save to test HMR
        </p>
      </div>
      <p className="read-the-docs">
        Click on the Vite and React logos to learn more
      </p>
    </>
  )
}

export default App

### lib-frontend/src/assets/react.svg ###
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
### lib-frontend/src/auth/useSession.ts ###
import { useQuery } from "@tanstack/react-query";
import { whoami } from "../api/session";
export function useSession(){
  return useQuery({ queryKey:["me"], queryFn: whoami, retry:false });
}

### lib-frontend/src/components/Layout.tsx ###
import { Link, Outlet, useNavigate } from "react-router-dom";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { logout } from "../api/session";
import { useSession } from "../auth/useSession";

export default function Layout(){
  const { data: me, isLoading } = useSession();
  const qc = useQueryClient();
  const nav = useNavigate();
  const m = useMutation({
    mutationFn: logout,
    onSuccess: () => { qc.clear(); nav("/login"); }
  });

  if (isLoading) return <div className="p-6">Loading…</div>;

  return (
    <div className="min-h-screen bg-base-300">
      <div className="navbar bg-base-200">
        <div className="navbar-start">
          <Link to="/dashboard" className="btn btn-ghost text-lg font-semibold">Library</Link>
        </div>
        <div className="navbar-center gap-2">
          <Link to="/books" className="btn btn-ghost btn-sm">Books</Link>
          <Link to="/loans" className="btn btn-ghost btn-sm">Loans</Link>
        </div>
        <div className="navbar-end gap-3">
          {me && (
            <>
              <span className="badge badge-outline">
                You: {me.email_address} {me.role === "librarian" ? "(librarian)" : "(member)"}
              </span>
              <button className="btn btn-sm btn-outline" onClick={()=>m.mutate()} disabled={m.isPending}>
                Logout
              </button>
            </>
          )}
        </div>
      </div>
      <div className="container mx-auto p-6">
        {/* Provide `me` to children */}
        <Outlet context={{ me }} />
      </div>
    </div>
  );
}

### lib-frontend/src/index.css ###
@tailwind base;
@tailwind components;
@tailwind utilities;

### lib-frontend/src/main.tsx ###
import ReactDOM from "react-dom/client";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { RouterProvider, createBrowserRouter } from "react-router-dom";
import routes from "./routes";
import "./index.css";
const qc = new QueryClient();
ReactDOM.createRoot(document.getElementById("root")!).render(
  <QueryClientProvider client={qc}>
    <RouterProvider router={createBrowserRouter(routes)} />
  </QueryClientProvider>
);

### lib-frontend/src/routes.tsx ###
import Login from "./screens/Login";
import Books from "./screens/Books";
import BookForm from "./screens/BookForm";
import Loans from "./screens/Loans";
import Guard from "./screens/Guard";
import Dashboard from "./screens/Dashboard";
import { Navigate } from "react-router-dom";
export default [
  { path:"/login", element:<Login/> },
  { path:"/", element:<Guard/>, children:[
    { index:true, element:<Navigate to="/dashboard" replace /> },
    { path:"/dashboard", element:<Dashboard/> },
    { path:"/books", element:<Books/> },
    { path:"/books/new", element:<BookForm mode="create"/> },
    { path:"/books/:id/edit", element:<BookForm mode="edit"/> },
    { path:"/loans", element:<Loans/> },
    { path:"*", element:<Navigate to="/dashboard" replace /> },
  ]},
];

### lib-frontend/src/screens/BookForm.tsx ###
import { useEffect, useState } from "react";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { createBook, getBook, updateBook } from "../api/books";
import { searchGenres, searchPeople } from "../api/lookups";
import { useNavigate, useParams } from "react-router-dom";

const LANGS = [
  { code: "en", label: "English" },
  { code: "pt", label: "Português" },
  { code: "es", label: "Español" },
];

type Opt = { id: number; name: string };

export default function BookForm({ mode }:{ mode:"create"|"edit" }){
  const { id } = useParams(); const nav=useNavigate(); const qc=useQueryClient();

  // fields
  const [title,setTitle]=useState(""); 
  const [isbn,setIsbn]=useState(""); 
  const [language,setLang]=useState("en");
  const [authors,setAuthors]=useState<Opt[]>([]);
  const [genres,setGenres]=useState<Opt[]>([]);

  // search
  const [authorQ,setAuthorQ]=useState(""); 
  const [genreQ,setGenreQ]=useState("");
  const { data:authorOpts=[] } = useQuery({ queryKey:["authors",authorQ], queryFn:()=>authorQ?searchPeople(authorQ):Promise.resolve([]) });
  const { data:genreOpts=[] }  = useQuery({ queryKey:["genres",genreQ],  queryFn:()=>genreQ?searchGenres(genreQ):Promise.resolve([]) });

  // load for edit
  const { data:book } = useQuery({ queryKey:["book",id], queryFn:()=>getBook(Number(id!)), enabled: mode==="edit" });
  useEffect(()=>{ 
    if(book){
      setTitle(book.title||""); setIsbn(book.isbn||""); setLang(book.language||"en");
      setAuthors((book.authors||[]).map((a:any)=>({id:a.id,name:a.name})));
      setGenres((book.genres||[]).map((g:any)=>({id:g.id,name:g.name})));
    }
  },[book]);

  // feedback state
  const [errors,setErrors]=useState<string[]>([]);
  const [ok,setOk]=useState(false);

  const payload = { title, isbn, language, author_ids: authors.map(a=>a.id), genre_ids: genres.map(g=>g.id) };

  const m = useMutation({
    mutationFn:()=> mode==="create" ? createBook(payload) : updateBook(Number(id), payload),
    onSuccess:()=>{ 
      setErrors([]); setOk(true);
      qc.invalidateQueries({queryKey:["books"]});
      setTimeout(()=>nav("/books"), 800);
    },
    onError:(e:any)=>{
      const msgs = e?.response?.data?.messages as string[] | undefined;
      setErrors(msgs?.length ? msgs : ["Save failed"]);
    }
  });

  const addAuthor = (opt: Opt) => { if(!authors.some(a=>a.id===opt.id)) setAuthors([...authors, opt]); setAuthorQ(""); };
  const removeAuthor = (i:number)=> setAuthors(authors.filter(a=>a.id!==i));
  const addGenre  = (opt: Opt) => { if(!genres.some(g=>g.id===opt.id)) setGenres([...genres, opt]); setGenreQ(""); };
  const removeGenre = (i:number)=> setGenres(genres.filter(g=>g.id!==i));

  return (
    <div className="max-w-xl mx-auto p-6 space-y-5">
      {ok && (
        <div className="toast toast-top toast-end z-50">
          <div className="alert alert-success"><span>Saved.</span></div>
        </div>
      )}
      {errors.length>0 && (
        <div className="alert alert-error">
          <div>
            <div className="font-semibold mb-1">Please fix:</div>
            <ul className="list-disc ml-5 text-sm">
              {errors.map((e,i)=><li key={i}>{e}</li>)}
            </ul>
          </div>
        </div>
      )}

      <h1 className="text-xl font-semibold">{mode==="create"?"New Book":"Edit Book"}</h1>

      <label className="form-control">
        <div className="label"><span className="label-text">Title</span></div>
        <input className={`input input-bordered w-full ${errors.find(x=>/Title/i.test(x))?"input-error":""}`}
               placeholder="Title" value={title} onChange={e=>setTitle(e.target.value)} />
      </label>

      <div className="grid sm:grid-cols-2 gap-4">
        <label className="form-control">
          <div className="label"><span className="label-text">ISBN</span></div>
          <input className={`input input-bordered w-full ${errors.find(x=>/ISBN/i.test(x))?"input-error":""}`}
                 placeholder="ISBN" value={isbn} onChange={e=>setIsbn(e.target.value)} />
        </label>

        <label className="form-control">
          <div className="label"><span className="label-text">Language</span></div>
          <select className="select select-bordered w-full" value={language} onChange={e=>setLang(e.target.value)}>
            {LANGS.map(l=> <option key={l.code} value={l.code}>{l.label}</option>)}
          </select>
        </label>
      </div>

      {/* Authors */}
      <section className="space-y-2">
        <div className="label"><span className="label-text">Authors</span></div>
        <div className="flex flex-wrap gap-2">
          {authors.map(a=>(
            <div key={a.id} className="badge badge-outline gap-2">
              {a.name}
              <button className="btn btn-ghost btn-xs" onClick={()=>removeAuthor(a.id)}>✕</button>
            </div>
          ))}
          {authors.length===0 && <div className="text-sm opacity-60">None selected</div>}
        </div>
        <input className="input input-bordered w-full bg-base-200" placeholder="Search authors…" value={authorQ} onChange={e=>setAuthorQ(e.target.value)} />
        {!!authorQ && authorOpts.length>0 && (
          <div className="mt-2 flex flex-wrap gap-2">
            {authorOpts.map((o:any)=>(
              <button key={o.id} type="button"
                className={`btn btn-outline btn-sm ${authors.some(a=>a.id===o.id)?"btn-active":""}`}
                onClick={()=>addAuthor({id:o.id,name:o.name})}>
                {o.name}
              </button>
            ))}
          </div>
        )}
      </section>

      {/* Genres */}
      <section className="space-y-2">
        <div className="label"><span className="label-text">Genres</span></div>
        <div className="flex flex-wrap gap-2">
          {genres.map(g=>(
            <div key={g.id} className="badge badge-outline gap-2">
              {g.name}
              <button className="btn btn-ghost btn-xs" onClick={()=>removeGenre(g.id)}>✕</button>
            </div>
          ))}
          {genres.length===0 && <div className="text-sm opacity-60">None selected</div>}
        </div>
        <input className="input input-bordered w-full bg-base-200" placeholder="Search genres…" value={genreQ} onChange={e=>setGenreQ(e.target.value)} />
        {!!genreQ && genreOpts.length>0 && (
          <div className="mt-2 flex flex-wrap gap-2">
            {genreOpts.map((o:any)=>(
              <button key={o.id} type="button"
                className={`btn btn-outline btn-sm ${genres.some(g=>g.id===o.id)?"btn-active":""}`}
                onClick={()=>addGenre({id:o.id,name:o.name})}>
                {o.name}
              </button>
            ))}
          </div>
        )}
      </section>

      <div className="flex gap-2">
        <button className={`btn btn-primary ${m.isPending?"loading":""}`} onClick={()=>m.mutate()} disabled={m.isPending}>
          {mode==="create"?"Create":"Save"}
        </button>
        <button className="btn btn-ghost" onClick={()=>nav(-1)} disabled={m.isPending}>Cancel</button>
      </div>
    </div>
  );
}

### lib-frontend/src/screens/Books.tsx ###
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { listBooks, deleteBook, addCopy, borrow } from "../api/books";
import { Link, useOutletContext, useNavigate } from "react-router-dom";

export default function Books(){
  const [q,setQ]=useState("");
  const [msg,setMsg]=useState<string|null>(null);
  const [borrowedIds,setBorrowedIds]=useState<Set<number>>(new Set());
  const qc=useQueryClient(); const nav = useNavigate();
  const { data:books=[] } = useQuery({ queryKey:["books",q], queryFn:()=>listBooks(q) });
  const me = (useOutletContext() as any)?.me; const isLib = me?.role==="librarian";

  const mDel=useMutation({ mutationFn:(id:number)=>deleteBook(id), onSuccess:()=>qc.invalidateQueries({queryKey:["books"]}) });
  const mCopy=useMutation({ mutationFn:({id,barcode}:{id:number,barcode:string})=>addCopy(id,barcode), onSuccess:()=>qc.invalidateQueries({queryKey:["books"]}) });
  const mBorrow=useMutation({
    mutationFn:(id:number)=>borrow(id),
    onSuccess:(data, id)=>{
      setBorrowedIds(prev=>new Set(prev).add(id as number));
      setMsg("Borrowed. View it on Loans.");
      qc.invalidateQueries({queryKey:["books"]});
      qc.invalidateQueries({queryKey:["loans"]});
    },
    onError:(e:any)=>{
      const code = e?.response?.status;
      const err  = e?.response?.data?.error;
      if(code===422 && err==="not_available") setMsg("Not available right now.");
      else if(code===409 && err==="already_borrowed") setMsg("You already borrowed this title.");
      else setMsg("Borrow failed.");
    }
  });

  const canBorrow = (b:any)=> !isLib && b.available_copies>0 && !borrowedIds.has(b.id);

  const Avail = ({n}:{n:number}) => (
    n>0
      ? <span className="font-semibold text-primary">{n}</span>
      : <span className="badge badge-outline text-error">Out</span>
  );

  return (
    <div className="p-6 space-y-4">
      {msg && (
        <div className="toast toast-top toast-end z-50">
          <div className="alert alert-info">
            <span>{msg}</span>
            <button className="btn btn-xs" onClick={()=>{ setMsg(null); nav("/loans"); }}>Go to Loans</button>
            <button className="btn btn-xs btn-ghost" onClick={()=>setMsg(null)}>Close</button>
          </div>
        </div>
      )}

      <div className="flex gap-2">
        <input className="input input-bordered flex-1 bg-base-200" placeholder="Search title/author/genre" value={q} onChange={e=>setQ(e.target.value)} />
        {isLib && <Link to="/books/new" className="btn btn-primary">New</Link>}
      </div>

      {/* Mobile cards */}
      <div className="md:hidden grid grid-cols-1 gap-3">
        {books.map((b:any)=>(
          <div key={b.id} className="card bg-base-200 shadow">
            <div className="card-body gap-2">
              <h2 className="card-title">{b.title}</h2>
              <div className="text-sm opacity-70">ISBN: {b.isbn || "—"}</div>
              <div className="text-sm">{b.genres?.map((g:any)=>g.name).join(", ")}</div>
              <div className="flex items-center gap-2">
                <Avail n={b.available_copies}/>
              </div>
              <div className="card-actions justify-end">
                {!isLib && (
                  <button
                    className="btn btn-sm"
                    disabled={!canBorrow(b) || mBorrow.isPending}
                    onClick={()=>mBorrow.mutate(b.id)}
                  >
                    {borrowedIds.has(b.id) ? "Borrowed" : "Borrow"}
                  </button>
                )}
                {isLib && (
                  <>
                    <Link to={`/books/${b.id}/edit`} className="btn btn-sm">Edit</Link>
                    <button className="btn btn-sm" onClick={()=>{ const barcode=prompt("Barcode?"); if(barcode) mCopy.mutate({id:b.id,barcode}); }}>Add Copy</button>
                    <button className="btn btn-sm btn-error" onClick={()=>mDel.mutate(b.id)}>Delete</button>
                  </>
                )}
              </div>
            </div>
          </div>
        ))}
      </div>

      {/* Desktop table */}
      <div className="hidden md:block overflow-x-auto bg-base-200 rounded-box p-2">
        <table className="table table-zebra">
          <thead><tr><th>Title</th><th>ISBN</th><th>Genres</th><th>Avail</th><th></th></tr></thead>
          <tbody>
            {books.map((b:any)=>(
              <tr key={b.id}>
                <td>{b.title}</td>
                <td>{b.isbn}</td>
                <td>{b.genres?.map((g:any)=>g.name).join(", ")}</td>
                <td><Avail n={b.available_copies}/></td>
                <td className="flex gap-2">
                  {!isLib && (
                    <button
                      className="btn btn-sm"
                      disabled={!canBorrow(b) || mBorrow.isPending}
                      onClick={()=>mBorrow.mutate(b.id)}
                    >
                      {borrowedIds.has(b.id) ? "Borrowed" : "Borrow"}
                    </button>
                  )}
                  {isLib && <>
                    <Link to={`/books/${b.id}/edit`} className="btn btn-sm">Edit</Link>
                    <button className="btn btn-sm" onClick={()=>{ const barcode=prompt("Barcode?"); if(barcode) mCopy.mutate({id:b.id,barcode}); }}>Add Copy</button>
                    <button className="btn btn-sm btn-error" onClick={()=>mDel.mutate(b.id)}>Delete</button>
                  </>}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
}

### lib-frontend/src/screens/Dashboard.tsx ###
import { useQuery } from "@tanstack/react-query";
import { listBooks } from "../api/books";
import { myLoans } from "../api/loans";
import { useOutletContext } from "react-router-dom";
const sod=(d:Date)=>{const x=new Date(d);x.setHours(0,0,0,0);return x;}
export default function Dashboard(){
  const { me } = (useOutletContext() as any) || { me:null };
  const { data:books=[] } = useQuery({ queryKey:["books",""], queryFn:()=>listBooks("") });
  const { data:loans=[] } = useQuery({ queryKey:["loans"], queryFn: myLoans });
  const now=new Date(); const t0=sod(now).getTime(), t1=t0+86400000;
  const active=loans.filter((l:any)=>!l.returned_at);
  const dueToday=active.filter((l:any)=>{const t=new Date(l.due_at).getTime();return t>=t0&&t<t1;});
  const overdue=active.filter((l:any)=> new Date(l.due_at).getTime()<now.getTime());
  return (
    <div className="p-6 space-y-6">
      <h1 className="text-xl font-semibold">Dashboard</h1>
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
        <Card title="Total books" value={books.length}/>
        <Card title="Borrowed (active)" value={active.length}/>
        <Card title="Due today" value={dueToday.length}/>
        <Card title="Overdue" value={overdue.length}/>
      </div>
    </div>
  );
}
function Card({title,value}:{title:string;value:number}){
  return <div className="stats shadow"><div className="stat"><div className="stat-title">{title}</div><div className="stat-value">{value}</div></div></div>;
}

### lib-frontend/src/screens/Guard.tsx ###
import { useEffect } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { useSession } from "../auth/useSession";
import Layout from "../components/Layout";

export default function Guard(){
  const { data, isLoading } = useSession();
  const nav = useNavigate(); const loc = useLocation();
  useEffect(()=>{
    if(!isLoading && data === null){
      nav("/login?next="+encodeURIComponent(loc.pathname));
    }
  },[isLoading, data, loc.pathname, nav]);

  if (isLoading) return <div className="p-6">Loading…</div>;
  return <Layout />;
}

### lib-frontend/src/screens/Loans.tsx ###
import { useMemo, useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { myLoans, returnLoan } from "../api/loans";
import { useOutletContext } from "react-router-dom";

const fmt = (d?: string) =>
  d ? new Date(d).toLocaleDateString(undefined, { year:"2-digit", month:"short", day:"2-digit" }) : "—";
const isOverdue = (l:any) => !l.returned_at && new Date(l.due_at) < new Date();
const displayMember = (l:any) =>
  l?.user_name || l?.user_email || (l?.user_id ? `Member #${l.user_id}` : "Unknown");

export default function Loans(){
  const { me } = (useOutletContext() as any) || { me:null };
  const isLib = me?.role === "librarian";
  const [scope,setScope] = useState<"library"|"mine">(isLib ? "library" : "mine");
  const { data:loans=[] } = useQuery({
    queryKey:["loans", scope],
    queryFn: () => fetchLoans(scope === "mine"),
  });
  const qc=useQueryClient();
  const m = useMutation({ mutationFn:(id:number)=>returnLoan(id), onSuccess:()=>qc.invalidateQueries({queryKey:["loans"]})});
  
  if (!isLib) return <MemberLoans loans={loans} />;
  
  return (
    <div className="space-y-4">
      <div className="join">
        <button className={`btn btn-sm join-item ${scope==="library"?"btn-primary":""}`} onClick={()=>setScope("library")}>Library loans</button>
        <button className={`btn btn-sm join-item ${scope==="mine"?"btn-primary":""}`} onClick={()=>setScope("mine")}>My loans</button>
      </div>
      <LibrarianLoans loans={loans} onReturn={(id)=>m.mutate(id)} loading={m.isPending} />
    </div>
  );
  
}

/* ----- Member view ----- */
function MemberLoans({ loans }: { loans:any[] }){
  return (
    <div>
      <h1 className="text-xl font-semibold mb-4">My Loans</h1>
      <div className="overflow-x-auto bg-base-200 rounded-box p-2">
        <table className="table">
          <thead><tr><th>Title</th><th>Borrowed</th><th>Due</th><th>Status</th></tr></thead>
          <tbody>
            {loans.map((l:any)=>{
              const borrowedAt = l.borrowed_at || l.created_at;
              const status = l.returned_at ? "Returned" : (isOverdue(l) ? "Overdue" : "Active");
              return (
                <tr key={l.id}>
                  <td className="max-w-[28ch] truncate">{l.loanable_title || l.title}</td>
                  <td>{fmt(borrowedAt)}</td>
                  <td>{fmt(l.due_at)}</td>
                  <td className={status==="Overdue" ? "text-error" : undefined}>{status}</td>
                </tr>
              );
            })}
          </tbody>
        </table>
      </div>
    </div>
  );
}

/* ----- Librarian view ----- */
function LibrarianLoans({
  loans,
  onReturn,
  loading
}:{
  loans:any[];
  onReturn:(id:number)=>void;
  loading:boolean;
}){
  const [tab,setTab] = useState<"active"|"overdue"|"dueToday"|"returned">("active");
  const [q,setQ] = useState("");

  const today0 = useMemo(()=>{ const d=new Date(); d.setHours(0,0,0,0); return d.getTime(); },[]);
  const tomorrow0 = today0 + 86400000;

  const filtered = useMemo(()=>{
    let xs = loans.slice();
    if (tab==="active") xs = xs.filter(l=>!l.returned_at);
    if (tab==="overdue") xs = xs.filter(l=>isOverdue(l));
    if (tab==="dueToday") xs = xs.filter(l=>{
      if (l.returned_at) return false;
      const t = new Date(l.due_at).getTime(); return t>=today0 && t<tomorrow0;
    });
    if (tab==="returned") xs = xs.filter(l=>!!l.returned_at);
    if (q) {
      const qq = q.toLowerCase();
      xs = xs.filter(l=>{
        const title = (l.loanable_title || l.title || "").toLowerCase();
        const who = displayMember(l).toLowerCase();
        return title.includes(qq) || who.includes(qq);
      });
    }
    return xs.sort((a,b)=> new Date(b.created_at||b.borrowed_at||b.due_at).getTime() - new Date(a.created_at||a.borrowed_at||a.due_at).getTime());
  },[loans,tab,q,today0,tomorrow0]);

  // group by borrower and compute overdue flags
  const groups = useMemo(()=>{
    const m = new Map<string,{key:string, rows:any[], overdueCount:number}>();
    for (const l of filtered){
      const key = displayMember(l);
      if (!m.has(key)) m.set(key,{key,rows:[],overdueCount:0});
      const g = m.get(key)!;
      g.rows.push(l);
      if (isOverdue(l)) g.overdueCount += 1;
    }
    return Array.from(m.values()).sort((a,b)=> a.key.localeCompare(b.key));
  },[filtered]);

  // build unique overdue members list from ALL loans (ignores tab/filter)
  const overdueMembers = useMemo(()=>{
    const set = new Map<string,number>(); // name -> count
    for (const l of loans) if (isOverdue(l)) {
      const key = displayMember(l);
      set.set(key, (set.get(key)||0)+1);
    }
    return Array.from(set.entries()).sort((a,b)=> b[1]-a[1]);
  },[loans]);

  const counts = {
    total: loans.length,
    active: loans.filter(l=>!l.returned_at).length,
    overdue: loans.filter(isOverdue).length,
    dueToday: loans.filter(l=>{
      if (l.returned_at) return false;
      const t = new Date(l.due_at).getTime(); return t>=today0 && t<tomorrow0;
    }).length,
    returned: loans.filter(l=>!!l.returned_at).length,
  };

  return (
    <div className="space-y-4">
      <h1 className="text-xl font-semibold">Loans — Librarian</h1>

      <div className="flex flex-wrap gap-2">
        <button className={`btn btn-sm ${tab==="active"?"btn-primary":""}`} onClick={()=>setTab("active")}>
          Active <span className="badge ml-2">{counts.active}</span>
        </button>
        <button className={`btn btn-sm ${tab==="overdue"?"btn-primary":""}`} onClick={()=>setTab("overdue")}>
          Overdue <span className="badge ml-2">{counts.overdue}</span>
        </button>
        <button className={`btn btn-sm ${tab==="dueToday"?"btn-primary":""}`} onClick={()=>setTab("dueToday")}>
          Due Today <span className="badge ml-2">{counts.dueToday}</span>
        </button>
        <button className={`btn btn-sm ${tab==="returned"?"btn-primary":""}`} onClick={()=>setTab("returned")}>
          Returned <span className="badge ml-2">{counts.returned}</span>
        </button>
        <div className="ml-auto">
          <input className="input input-bordered input-sm bg-base-200" placeholder="Search title or member…" value={q} onChange={e=>setQ(e.target.value)} />
        </div>
      </div>

      {/* Overdue members panel */}
      {overdueMembers.length>0 && (
        <div className="bg-base-200 rounded-box p-3">
          <div className="mb-2 font-medium">Overdue members</div>
          <div className="flex flex-wrap gap-2">
            {overdueMembers.map(([name,count])=>(
              <span key={name} className="badge badge-outline">
                {name} <span className="ml-1 text-error">({count})</span>
              </span>
            ))}
          </div>
        </div>
      )}

      {groups.length===0 ? (
        <div className="alert"><span>No loans match.</span></div>
      ) : (
        <div className="space-y-4">
          {groups.map(g=>(
            <div key={g.key} className="bg-base-200 rounded-box p-3">
              <div className="flex items-center justify-between mb-2">
                <div className="font-medium flex items-center gap-2">
                  <span>{g.key}</span>
                  {g.overdueCount>0 && <span className="badge badge-outline text-error">Overdue {g.overdueCount}</span>}
                </div>
                <div className="text-sm opacity-70">{g.rows.filter((r:any)=>!r.returned_at).length} active</div>
              </div>
              <div className="overflow-x-auto">
                <table className="table table-sm">
                  <thead>
                    <tr>
                      <th>Title</th>
                      <th>Borrowed</th>
                      <th>Due</th>
                      <th>Status</th>
                      <th></th>
                    </tr>
                  </thead>
                  <tbody>
                    {g.rows.map((l:any)=>{
                      const borrowedAt = l.borrowed_at || l.created_at;
                      const status = l.returned_at ? "Returned" : (isOverdue(l) ? "Overdue" : "Active");
                      return (
                        <tr key={l.id}>
                          <td className="max-w-[40ch] truncate">{l.loanable_title || l.title}</td>
                          <td>{fmt(borrowedAt)}</td>
                          <td>{fmt(l.due_at)}</td>
                          <td className={status==="Overdue" ? "text-error" : undefined}>{status}</td>
                          <td>
                            {!l.returned_at && (
                              <button className="btn btn-xs" onClick={()=>onReturn(l.id)} disabled={loading}>
                                Return
                              </button>
                            )}
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

### lib-frontend/src/screens/Login.tsx ###
import { useState } from "react";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { login } from "../api/session";
import { useNavigate, useSearchParams } from "react-router-dom";
export default function Login(){
  const [email,setE]=useState(""); const [pw,setP]=useState("");
  const qc=useQueryClient(); const nav=useNavigate(); const [sp]=useSearchParams();
  const m = useMutation({ mutationFn:()=>login(email,pw), onSuccess:()=>{ qc.invalidateQueries({queryKey:["me"]}); nav(sp.get("next")||"/dashboard"); }});
  return (
    <div className="min-h-screen flex items-center justify-center bg-base-100">
      <div className="card w-full max-w-sm bg-base-200 shadow">
        <div className="card-body gap-3">
          <h1 className="card-title">Login</h1>
          <input className="input input-bordered w-full" placeholder="email" value={email} onChange={e=>setE(e.target.value)} />
          <input className="input input-bordered w-full" type="password" placeholder="password" value={pw} onChange={e=>setP(e.target.value)} />
          <button className="btn btn-primary w-full" onClick={()=>m.mutate()} disabled={m.isPending}>Sign in</button>
          {m.error && <div className="alert alert-error text-sm">Login failed</div>}
        </div>
      </div>
    </div>
  );
}
